""" Visualization of the map feature map (map representation) generated by encoding map elements.
"""

import random

import numpy as np
import mayavi.mlab as mlab
from tqdm import tqdm

from visualization.visualization_basics import convert_color_strings_to_rgb


# Module functions #####################################################################################################
########################################################################################################################


def vis_map_fm(map_fm, fm_extent):
    """ Visualizes a map feature map.
    Args:
        map_fm (float tensor): feature map as [X, Y, Z, num_map_features] with X, Y, Z voxels
        fm_extent (list[list]): feature map extent as [[x_min, x_max], [y_min, y_max], [z_min, z_max]]
    """
    # Get all map_fm indices with marked elements and the element types
    map_fm = map_fm[:, :, :, :3]
    marked_voxels = np.transpose(np.nonzero(map_fm))

    # For every index calculate original position using fm_extent and plot cube in type-unique color
    # Get voxel size based on fm shape and extent
    voxel_size = []
    for i in range(3):
        voxel_size.append(abs(fm_extent[i][0] - fm_extent[i][1]) / map_fm.shape[i])

    colors = [
        "Darkviolet",   # lights
        "Coral",        # poles
        "Aqua"          # signs
    ]
    colors = convert_color_strings_to_rgb(colors)
    print("Plotting marked voxels (map_fm) ...")

    for voxel in tqdm(marked_voxels):
        # Get original position
        voxel_pos = [(voxel[i] * voxel_size[i]) + fm_extent[i][0] + (voxel_size[i] / 2) for i in range(3)]

        voxel_pos[2] -= voxel_size[2] / 2  # we need bottom z position for bar charts
        mlab.barchart(voxel_pos[0], voxel_pos[1], voxel_pos[2], voxel_size[2], color=colors[voxel[3]],
                      mode='cube', lateral_scale=voxel_size[0], opacity=.2)


def vis_map_lut(map_lut, map_fm, fm_extent):
    """ Visualizes the map lookup table (LUT) created during map encoding (maps element ID to list of voxels).

    The set of unique voxels matching to an element is displayed as random colors.

    Args:
        map_lut (dict:list): list of element IDs with matched voxels as list of tuples (type->id->list of tuples)
        map_fm (float tensor): [X, Y, Z, num_map_features] map representation
        fm_extent (list[list]): feature map extent as [[x_min, x_max], [y_min, y_max], [z_min, z_max]]
    """
    # Settings
    vis_discretization = True   # visualizes matching voxels using random colors
    vis_conflicts = False       # visualizes conflicting voxels in red

    # For every index calculate original position using fm_extent and plot cube in type-unique color
    # Get voxel size based on fm shape and extent
    voxel_size = []
    for i in range(3):
        voxel_size.append(abs(fm_extent[i][0] - fm_extent[i][1]) / map_fm.shape[i])

    # Visualize discretization
    if vis_discretization:
        for elem_type in map_lut['lut'].keys():
            for elem_id in map_lut['lut'][elem_type].keys():
                voxels = map_lut['lut'][elem_type][elem_id]

                r = random.uniform(0, 1)
                g = random.uniform(0, 1)
                b = random.uniform(0, 1)
                for voxel in voxels:
                    voxel_pos = [(voxel[i] * voxel_size[i]) + fm_extent[i][0] + (voxel_size[i] / 2) for i in range(3)]
                    voxel_pos[2] -= voxel_size[2] / 2  # we need bottom z position for bar charts
                    mlab.barchart(voxel_pos[0], voxel_pos[1], voxel_pos[2], voxel_size[2], color=(r, g, b),
                                  mode='cube', lateral_scale=voxel_size[0], opacity=.4)

    # Visualize conflicts
    if vis_conflicts:
        if 'conflicting_elements' in map_lut.keys():
            conflicting_elements = map_lut['conflicting_elements']
            for element in conflicting_elements:
                conflicting_voxels = element['conflicting_voxels']
                print(conflicting_voxels)
                for conflict_voxel in conflicting_voxels:
                    voxel_pos = [(conflict_voxel[i] * voxel_size[i]) + fm_extent[i][0] + (voxel_size[i] / 2) for i in range(3)]
                    voxel_pos[2] -= voxel_size[2] / 2  # we need bottom z position for bar charts
                    mlab.barchart(voxel_pos[0], voxel_pos[1], voxel_pos[2], voxel_size[2], color=(1, 0, 0),
                                  mode='cube', lateral_scale=voxel_size[0], opacity=.4)
        else:
            print("[Warning] vis map fm: no conflict voxels.")
